# Research-Assignment_GraphQL
The objective of this assignment is getting familiar with the implementation of GraphQL as a query language and API in service integration

## Questions

**1. What is GraphQL, what is it used for, and why does it contain ‘graph’ in its title?**

GraphQL is a query language and server-side runtime for application programming interfaces (APIs) that prioritizes giving clients exactly the data they request and no more. 

The logo for GraphQL is definitely a graph theoretical graph. I believe the reason is because the data it is supposed to retrieve is graph theoretical in nature. Facebook created it for their purposes, and the company has a sizable social network (aka a graph). You can see in the [description](https://engineering.fb.com/2015/09/14/core-data/graphql-a-data-query-language/) that they view of data as "a graph of objects" and that it works well with "graph-structured data stores." 


**2. Which known drawbacks of implementing API gateways in service integration could be resolved by GraphQL?**

It removes the risk of complexity since Graphql elimaties that all the rules are placed in one place. Configuring your application and API to interact via an API Gateway will require some more orchestration which will add a level of difficulty for the developers. Graphql can solve this issue by removing the complex orchestration into simple graph object setup.


**3. How does GraphQL compare to RESTful API and gRPC? Which are the appropriate use cases for implementing each of these technologies?**

| Feature                | GraphQL                                                                                                                                                            | REST                                                                                                             | gRPC                                                                                                                                         |
|------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------|
| Data fetch             | Efficient fetching of data. Only required data will be fetched from server.                                                                                        | Extra data might be returned by the server unless new endpoints/query filters are defined on server side.        | Extra data might be returned by server unless new endpoints/filters are defined on server side.                                              |
| HTTP 1.1 vs HTTP 2     | Follows request-response model. It can work with either HTTP version but is typically built with HTTP 1.1.                                                         | Follows request-response model. It can work with either HTTP version but is still typically built with HTTP 1.1. | Follows client-response model and is based on HTTP 2. Some servers have workarounds to make it work with HTTP 1.1 but it is not the default. |
| Payload data structure | Uses JSON-based payloads to send/receive data.                                                                                                                     | Mostly uses JSON- and XML-based payloads to send/receive data.                                                   | Uses Protocol Buffers by default to serialize payload data.                                                                                  |
| Browser support        | Works everywhere.                                                                                                                                                  | Works everywhere.                                                                                                | Limited support. Need to use gRPC-Web, which is an extension of gRPC for the web and is based on HTTP 1.1.                                   |
| Code generation        | Need to use third-party tools like GraphQL Code Generator to generate client code. Docs and an interactive playground can be natively generated by using GraphiQL. | Need to use third-party tools like Swagger to generate client code.                                              | gRPC has native support for code generation for various target languages.                                                                    |
| Request caching        | Hard to cache requests by default as every request is sent to the same endpoint.                                                                                   | Easy to cache requests on the client and server sides. Most clients/servers natively support it.                 | Doesn’t support request/response caching by default.                                                                                         |

The best API technology for your specific project will depend on what you are trying to achieve. If you need a generic API that will be used by a lot of clients, then REST might be your best option.

If you need a flexible API that different clients will use to make many unique requests, then it might be best to let the clients create their own unique queries and get only the specific data they need quickly, and you can achieve this with GraphQL.

If want to create fast, seamless communication between internal services, then gRPC is your best option.

## How to Run the sample GraphQL program

1. Run this command : Add-Migration Initial

2. Run this command : Update-Database

3. Change the DbConnection string

4. Run the application.
